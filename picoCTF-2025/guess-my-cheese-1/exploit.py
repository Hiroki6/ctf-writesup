# E(x) = (a * x + b) mod 26
# D(y) = a_inv * (y - b) mod 26
from z3 import *
import string
from pwn import *
import re

def modinv(a, m):
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    raise ValueError(f"No modular inverse for a={a} under mod {m}")

def encrypt(plaintext, a, b):
    return string.ascii_uppercase[(a * string.ascii_uppercase.index(plaintext) + b) % 26]

def decrypt(ciphertext, a, b):
    answer = ""
    for c in ciphertext:
        answer += string.ascii_uppercase[(a * (string.ascii_uppercase.index(c) - b)) % 26]
    return answer

context.log_level = 'info'
HOST = "verbal-sleep.picoctf.net"
PORT = 49370
plaintext = "CHEDDAR"
ciphertext = ""
target_ciphertext = ""

r = remote(HOST, PORT)
# 1. parse target cipher
res = r.recvuntil(b"What would you like to do?")
match = re.search(r"guess it:\s+([A-Z]+)", res.decode())
if match:
    target_ciphertext = match.group(1)
    info(f"Target ciphertext: {target_ciphertext}")

# 2. encrypt CHEDDAR to find a and b
r.sendline(b"e")  # choose 'encrypt'

r.recvuntil(b"What cheese would you like to encrypt?")
r.sendline(plaintext.encode()) 
res = r.recvuntil(b"What would you like to do?")
match = re.search(r" Here's your encrypted cheese:\s+([A-Z]+)", res.decode())
if match:
    ciphertext = match.group(1)
    info(f"Ciphertext: {ciphertext} of {plaintext}")


# 3. decrypt target cipher
a = Int('a')
b = Int('b')

s = Solver()
for i, c in enumerate(plaintext):
    x = string.ascii_uppercase.index(c)
    y = string.ascii_uppercase.index(ciphertext[i])
    s.add((a * x + b) % 26 == y)

if s.check() == sat:
    model = s.model()
    a_val = model[a].as_long()
    b_val = model[b].as_long()
    info(f"Solved: a = {a_val}, b = {b_val}")
    a_inv = modinv(a_val, 26)
    decrypted = decrypt(target_ciphertext, a_inv, b_val)
    info(f"Decrypted: {decrypted}")
    r.sendline(b"g")
    r.recvuntil(b"So...what's my cheese?")
    r.sendline(decrypted.encode())
    r.interactive()
else:
    info("No solution found.")
